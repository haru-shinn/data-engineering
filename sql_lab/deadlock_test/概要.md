# デッドロック誘発実験

## 検証内容

2つの異なるトランザクションが、お互いに相手がロックしているデータを更新しようとして、処理が止まってしまう状態の作成。

## 準備

高負荷の作り方: 複数の接続から、異なる順番（A→BとB→A）で複数の行を更新する。

## ポイント

- PostgreSQLがどのようにデッドロックを検知し、どちらのトランザクションを「生贄（ロールバック）」にするか。
- アプリケーション側で「リトライ処理」が必要になる理由の理解。

## 単語

### ロック

|実験対象|確認観点|想定結果|
|--|--|--|
|共有ロック (SHARE)|複数のトランザクションが同時に同じリソースに対して共有ロックを取得できるか？|複数のトランザクションが成功してロックを取得できる。データの読み取りは可能。|
|専有ロック (EXCLUSIVE)|専有ロックを取得したトランザクションがある状態で、他のトランザクションが共有ロックや専有ロックを取得しようとした場合、どのように振る舞うか？|共有ロック・専有ロックともに、先に取得したトランザクションがコミットまたはロールバックするまで、待機（ブロック）状態になる。データの変更や読み取りを防止する。|
|デッドロック|2つ以上のトランザクションが、互いに相手がロックしているリソースの解放を待ち合う循環待ちの状態を意図的に作り出せるか？|PostgreSQLがデッドロックを検知し、いずれか一方のトランザクションを強制的に終了（ロールバック）させることで、デッドロック状態を解消する。|
|ロックの解放|ロックを取得したトランザクションがCOMMITまたはROLLBACKした場合、ロックは解放されるか？ 待機中のトランザクションはどうなるか？|COMMITまたはROLLBACKが実行されるとロックが解放され、待機していたトランザクションのうち、次のロック取得権を持つものが処理を再開する。|

### トランザクション

|現象名|説明|
|--|--|
|ダーティリード (Dirty Read)|他のトランザクションがまだコミットしていない（変更される可能性がある）データを読み取ってしまう現象。※PostgreSQLではどの分離レベルでも発生しない。|
|ノンリピータブルリード (Non-repeatable Read)|あるトランザクション内で同じデータを複数回読み込んだ際に、その間に他のトランザクションがデータをUPDATEしてコミットしたため、読み込むたびに値が変わってしまう現象。|
|ファントムリード (Phantom Read)|あるトランザクション内で同じ検索条件でSELECTを複数回実行した際に、その間に他のトランザクションが条件に一致するデータをINSERTまたはDELETEしてコミットしたため、行数やデータ集合が変わってしまう現象。|

|分離レベル (PostgreSQL)|現象の制御|確認観点|想定結果|
|--|--|--|--|
|Read Committed|ノンリピータブルリードとファントムリードが発生する可能性がある。|T1がUPDATEをコミットした後に、T2が同じデータを再度SELECTするとどうなるか？|T2はT1のコミットされた新しい値を読み取る (ノンリピータブルリード発生)。|
|Repeatable Read|ノンリピータブルリードは防止されるが、ファントムリードが発生する可能性がある。|T1がUPDATEやINSERTをコミットした後に、T2が同じデータを再度SELECTするとどうなるか？|T2はトランザクション開始時の古い値を読み取り続ける (ノンリピータブルリード防止)。しかし、INSERTによる行数の変化は検知してしまう可能性がある（ファントムリード）。|
|Serializable|すべての現象を防止し、トランザクションが直列に実行された場合と同じ結果を保証する。|ノンリピータブルリード、ファントムリードを引き起こすような処理を試みた際、どのようなエラーが発生するか？|T1またはT2のいずれかが**ERROR: could not serialize access due to concurrent updateなどのシリアライズエラー**でロールバックさせられる。|

## 実験用のクエリ

（注意）ddl.sql内のテーブルとは違う名前で手順書を作成しているため適宜変更すること

### ロックに関する実験

#### 共有ロックと専有ロック

|手順|セッションA (トランザクション1)|セッションB (トランザクション2)|確認観点|
|--|--|--|--|
|1|BEGIN;|BEGIN;|トランザクション開始|
|2|SELECT * FROM accounts WHERE id = 1 FOR UPDATE;||専有ロックの取得（待機させる）|
|3||SELECT * FROM accounts WHERE id = 1 FOR SHARE;|共有ロックの取得を試みる|
|4||結果： 実行が**ブロック（待機）される。|専有ロックは共有ロックの取得をブロックする。|
|5|ROLLBACK;||Aがロールバックするとロックが解放される。|
|6||結果： Bの処理が再開され、共有ロックが取得成功**する。|待機していた処理が再開するか。|

※共有ロック中に専有ロックはかけられない

#### デッドロック

|手順|セッションA (トランザクション1)|セッションB (トランザクション2)|確認観点|
|--|--|--|--|
|1|BEGIN;|BEGIN;|トランザクション開始|
|2|SELECT * FROM accounts WHERE id = 1 FOR UPDATE;||Aがid=1にロック取得|
|3||SELECT * FROM accounts WHERE id = 2 FOR UPDATE;|Bがid=2にロック取得|
|4|SELECT * FROM accounts WHERE id = 2 FOR UPDATE;||AがBのロック (id=2) を要求 $\rightarrow$ 待機|
|5||SELECT * FROM accounts WHERE id = 1 FOR UPDATE;|BがAのロック (id=1) を要求|
|6||結果： デッドロックエラーが発生し、Bが強制的にロールバックされる (ERROR: deadlock detected)。|PostgreSQLがデッドロックを検知・解消するか。|

### トランザクション分離レベルに関する実験

#### Read Committed

|手順|セッションA (トランザクション1)|セッションB (トランザクション2)|確認観点|
|--|--|--|--|
|1|BEGIN; SET TRANSACTION ISOLATION LEVEL READ COMMITTED;|BEGIN; SET TRANSACTION ISOLATION LEVEL READ COMMITTED;|トランザクション開始|
|2|SELECT balance FROM accounts WHERE id = 1; 結果：100||最初の読み取り|
|3||UPDATE accounts SET balance = 999 WHERE id = 1; COMMIT;|Bがデータを更新してコミット|
|4|SELECT balance FROM accounts WHERE id = 1;||2回目の読み取り|
|5|結果：999||T2の変更が反映されるか (ノンリピータブルリード発生)。|
|6|COMMIT;|||

#### Repeatable Read

|手順|セッションA (トランザクション1)|セッションB (トランザクション2)|確認観点|
|--|--|--|--|
|1|BEGIN; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;|BEGIN; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;|トランザクション開始|
|2|SELECT balance FROM accounts WHERE id = 1; 結果：100||最初の読み取り|
|3||UPDATE accounts SET balance = 888 WHERE id = 1; COMMIT;|Bがデータを更新してコミット|
|4|SELECT balance FROM accounts WHERE id = 1;||2回目の読み取り|
|5|結果：100||T2の変更が反映されないか (ノンリピータブルリード防止)。|
|6|COMMIT;|||

※PostgreSQLは、ファントムリード（他人が追加した新しい行が見えてしまう現象）も自動的に防止する。

#### Serializable

PostgreSQLでは失敗しない手順

|手順|セッションA (トランザクション1)|セッションB (トランザクション2)|確認観点|
|--|--|--|--|
|1|BEGIN; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;|BEGIN; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;|トランザクション開始|
|2|SELECT COUNT(*) FROM accounts WHERE balance > 0; 結果：2||最初の読み取り（集計）|
|3||INSERT INTO accounts (id, balance) VALUES (3, 50); COMMIT;|Bが条件に一致するデータを追加してコミット|
|4|SELECT COUNT(*) FROM accounts WHERE balance > 0;||2回目の読み取り（集計）|
|5|結果：2||T2の変更が反映されない（Repeatable Readと同じ結果）。|
|6|COMMIT;||Aがコミットを試みる|
|7|||T2の変更（ファントムとなる可能性）を検知し、Aでシリアライズエラーが発生して強制的にロールバックされる。 (ERROR: could not serialize access due to concurrent update)※PostgreSqlでは発生しない。|

PostgreSQLで失敗する手順

|手順|セッションA (Serializable)|セッションB (Serializable)|解説|
|--|--|--|--|
|1|BEGIN; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;|BEGIN; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;|トランザクション開始|
|2|SELECT SUM(balance) FROM accounts; (結果: 100)||Aが合計を確認|
|3||SELECT SUM(balance) FROM accounts; (結果: 100)|Bも合計を確認|
|4|UPDATE accounts SET balance = balance - 100 WHERE id = 1;||Aが自分の読み取りを信じて引き出し|
|5||UPDATE accounts SET balance = balance - 100 WHERE id = 2;|Bも自分の読み取りを信じて引き出し|
|6|COMMIT; (成功)||Aは先にコミット成功|
|7||COMMIT; (ここでエラー！)|Bは「Aの更新を考慮すると、手順3のSUMの結果が変わってしまうはずだ」と検知され、失敗する。|
