# SQLと理論

SQLの背後には強力な数学的基盤が存在。
主に**集合論**と**述語論理**、そしてこれらをデータベース操作として体系化した**関係代数**の3つが柱となっている。

[[目次]]

- [SQLと理論](#sqlと理論)
  - [集合論 (Set Theory)](#集合論-set-theory)
  - [述語論理 (Predicate Logic)](#述語論理-predicate-logic)
  - [関係代数 (Relational Algebra)](#関係代数-relational-algebra)
  - [各理論の関係性](#各理論の関係性)
    - [各理論の役割とつながり](#各理論の役割とつながり)
    - [実務的な関係性の例](#実務的な関係性の例)
    - [なぜこの4つが必要なのか](#なぜこの4つが必要なのか)
  - [理論がSQLにもたらした「3値論理」](#理論がsqlにもたらした3値論理)

---

## 集合論 (Set Theory)

集合論は、SQLの「データは重複のない（理想的には）塊である」という考え方の根底にある。SQLでは、テーブルそのものを一つの「集合」として扱う。

- **SQLでの表現:** `UNION`, `INTERSECT`, `EXCEPT`（集合演算）
- **具体的な仕組み:** * **和集合 (`UNION`):** 2つの集合を合わせる。
- **積集合 (`INTERSECT`):** 両方の集合に共通するものだけ抜き出す。
- **差集合 (`EXCEPT` / `MINUS`):** 片方の集合からもう片方の要素を取り除く。

> **ポイント:** SQLの `SELECT` 結果もまた一つの「集合（リレーション）」であるため、その結果に対してさらに `SELECT` をかける（サブクエリ）という「入れ子構造」が可能になる。

---

## 述語論理 (Predicate Logic)

述語論理は、SQLの「絞り込み条件」の正体。「述語」とは、値を受け取って「真 (True)」か「偽 (False)」を返す関数のこと。

- **SQLでの表現:** `WHERE` 句、`HAVING` 句、`ON` 句
- **具体的な仕組み:** * `WHERE age >= 20` という記述は、数学的には  という述語。
- データベースは、テーブル内の各行（要素）に対してこの述語を評価し、**「真（True）」となる行だけを抽出**する。
- `AND`, `OR`, `NOT` といった論理演算子で述語を組み合わせるのも、まさに論理学そのもの。

---

## 関係代数 (Relational Algebra)

集合論をさらに発展させ、エドガー・F・コッド博士が提唱した「データ操作のための演算体系」。SQLの各句は、この演算に直接対応している。

| 関係代数の演算 | SQLでの表現 | 意味 |
| --- | --- | --- |
| **射影 (Projection)** | `SELECT column` | 特定の列だけを抜き出す |
| **制限 (Selection)** | `WHERE condition` | 特定の行だけを抜き出す |
| **結合 (Join)** | `JOIN ... ON` | 共通の属性を持つ2つの集合を合体させる |
| **直積 (Cartesian Product)** | `CROSS JOIN` | 2つの集合の全組み合わせを作る |

---

## 各理論の関係性

「集合論・述語論理」がルール（文法）を作り、「関係代数」が計算の仕組み（式）を作り、「計算量理論」がその実行速度（効率）を保証するという構造

|フェーズ|役割|担当する理論|
|--|--|--|
|宣言 (注文)|データの条件を定義する|述語論理・集合論|
|翻訳 (変換)|命令を実行可能な「式」に変換する|関係代数|
|最適化 (計画)|最も速い手順を選択する|計算量理論|
|実行 (調理)|物理的なデータアクセス|物理層（B-Treeなど）|

### 各理論の役割とつながり

- 集合論 ↔ 述語論理（データの定義）
    この2つは「表裏一体」の関係。集合論は、データの「塊（入れ物）」を定義する。述語論理は、その塊から要素を取り出すための「フィルター（条件）」を定義する。
    つながり: 「年齢が20歳以上」という述語を評価することで、「成人」という部分集合が作成される。

- 述語論理・集合論 ↔ 関係代数（処理の数式化）
    SQLという「言葉」を、コンピュータが計算できる「数式」に橋渡しするのが関係代数。
    役割: SELECT や JOIN といった操作を演算記号に置き換えます。
    つながり: 宣言型であるSQLは、そのままでは実行手順が不明確であるため、関係代数という「代数式」に変換することで、**「計算可能な手順」**へと具体化される。

- 関係代数 ↔ 計算量理論（効率の追求）
  ここが**「最適化（オプティマイザ）」**の核心。
  役割: 同じ結果を導く「関係代数の式」は、数学的に何通りも存在する（例：先に絞り込んでから結合するか、結合してから絞り込むか）。
  つながり: 計算量理論を用いて、複数ある代数式の中から、最もステップ数（計算コスト）が少ないものを選び出しす。例えば、「$O(n)$ ではなく $O(\log n)$ で済む経路」が選択される。

### 実務的な関係性の例

**JOINの最適化**
例えば「100万件の顧客テーブル」と「10件の店舗テーブル」を結合する場合

- 集合論・述語論理: 「店舗IDが一致する顧客と店舗のペア」という集合を定義する。
- 関係代数: Customer ⋈ Store（結合演算）という式を作る。
- 計算量理論
  - プランA：100万件を全スキャンして10件を探す（コスト大）。
  - プランB：先に10件の店舗をメモリに読み込み、顧客のインデックスを引く（コスト小）。

結論: 計算量理論に基づき、オプティマイザはプランBを採用する。

### なぜこの4つが必要なのか

**集合論**がないと、データの入れ物を定義できない。
**述語論理**がないと、欲しいデータを指定（検索）できない。
**関係代数**がないと、宣言を計算手順に変換できない。
**計算量理論**がないと、現実的な時間で処理が終わらない。

---

## 理論がSQLにもたらした「3値論理」

実務上のSQLにおいて、理論が最も色濃く出ているのが **「NULL」の扱い** 。
通常の論理学は「真・偽」の2値であるが、SQLは **「真・偽・不明 (Unknown)」** の **3値論理 (Three-valued logic)** を採用している。

- `age = 20` が、データが NULL の場合に `False` ではなく `Unknown` になるのは、述語論理を「不完全な情報が存在する現実世界」に適応させた結果。

---
