# SQL

[[目次]]

- [SQL](#sql)
  - [特性関数](#特性関数)
  - [存在量化と全称量化](#存在量化と全称量化)
  - [集合論と述語論理](#集合論と述語論理)

## 特性関数

- 特性関数とは
  - 特定の条件を満たすかどうかを判定し、その結果を数値（主に 1 または 0）として返す手法のこと。
  - ある要素 $x$ が集合 $A$ に含まれるかどうかを以下のように定義する。
    条件を満たす場合：1条件を満たさない場合：0
  - 基本的な書き方
    CASE WHEN 条件 THEN 1 ELSE 0 END
- 重要性（メリット）
  - WHERE句によるフィルタリングは行そのものを削除するが、特性関数は行を維持したまま、特定の条件にイッツするものだけをカウント・合計することが可能となる。
  - 活用例
    - 「全体の売上」と「特定の商品の売上」を横並びで表示
    - ピボットが可能
    - Nullの制御（count(*) はNullをカウントするが、count(xxx) はNullをカウントしないため、歯抜けの確認が可能）
- 具体例
  - 例1：カテゴリ別の集計（条件付きカウント）
    - ユーザーテーブルから「男性の数」と「女性の数」を一度に集計したい場合

    ```sql
    SELECT
        COUNT(CASE WHEN gender = 'male' THEN 1 END) AS male_count,
        COUNT(CASE WHEN gender = 'female' THEN 1 END) AS female_count
    FROM users;
    ```

  - 例2：フラグ立てによるスコアリング
    - 複数の条件を判定して、ユーザーのランクを計算する場合

    ```sql
    SELECT
        user_id,
        (CASE WHEN login_days > 10 THEN 1 ELSE 0 END +
        CASE WHEN purchase_count > 5 THEN 1 ELSE 0 END) AS loyalty_score
    FROM user_stats;
    ```

- 特性関数を使う際のポイント
  - SUMとCOUNTの使い分け
    - 条件に合う数を足し合わせる

    ```sql
    SUM(CASE WHEN ... THEN 1 ELSE 0 END)
    ```

    - Nullを数えない性質の利用

    ```sql
    COUNT(CASE WHEN ... THEN 1 ELSE NULL END)
    ```

- 参照： ミック（2018）達人に学ぶSQL徹底指南書第２版　初級者で終わりたくないあなたへ　株式会社翔泳社p186-236

---

## 存在量化と全称量化

- **存在量化**
  - 「少なくとも一つ存在する」こと。
  - 「条件に合うものが、少なくとも1つはあるか？」 を判定する。
  - EXISTS（条件に一致する行が1つでも見つかった時点で TRUE を返し、探索を終了する。）
- **全称量化**
  - 「すべての～について成り立つ」こと。
  - 「すべてのデータが、ある条件を満たしているか？」 を判定する。
  - NOT EXISTS （「（条件を満たさないものは）存在しない」）
  - 全称量化の公式:
「すべての $x$ が $P$ である」 ＝ 「$P$ でない $x$ が 存在しない (NOT EXISTS)」

**イメージ**
例：全員が合格点（80点以上）のクラスを探す
命題： クラスの全員が80点以上である。

数学的な否定（反例）： 80点未満の生徒が一人でもいる。

SQLの論理： 「80点未満の生徒」が NOT EXISTS（存在しない） クラスを抽出する。

```sql
SELECT DISTINCT ClassName
FROM Students S1
WHERE NOT EXISTS (
    -- ここで「反例（80点未満の生徒）」を探しに行く
    SELECT 1
    FROM Students S2
    WHERE S2.ClassName = S1.ClassName -- 同じクラスの中で
      AND S2.Score < 80                -- 80点未満の生徒
);
```

- 実行のイメージ（3つのクラスがあると仮定）
  - クラスA：全員90点
    - サブクエリ：80点未満を探す → いない！
    - NOT EXISTS の判定：TRUE（合格）
  - クラスB：85点、40点、90点
    - サブクエリ：80点未満を探す → 40点の生徒が見つかった！
    - NOT EXISTS の判定：FALSE（脱落）
  - クラスC：全員70点
    - サブクエリ：80点未満を探す → 全員見つかった！
    - NOT EXISTS の判定：FALSE（脱落）

結果、クラスAだけが抽出される。

- 参照：
  - Geminiによる例
  - ミック（2018）達人に学ぶSQL徹底指南書第２版　初級者で終わりたくないあなたへ　株式会社翔泳社p151-185

---

## 集合論と述語論理

- パフォーマンス

- 可読性
  SQLは「何を取得したいか」という宣言的な言語。
  - EXISTS: 「〜が存在するかどうか」という意図がストレートに伝わる。
  - GROUP BY: 「集計」のための構文。存在チェックのために集計関数を駆使すると、他のエンジニアがコードを見た際、「なぜここで集計しているのか？」と意図を読み解くのに一歩時間がかかる。

- 具体的な書き方の違い
「注文履歴が1件でもあるユーザー」を探す例で比較する

  - EXISTS を使う場合（推奨）

    ```sql
    SELECT *
    FROM Users u
    WHERE EXISTS (
        SELECT 1 
        FROM Orders o 
        WHERE o.user_id = u.id
    );
    ```

  - GROUP BY と特性関数（集計）を使う場合

    ```sql
    SELECT u.*
    FROM Users u
    JOIN Orders o ON u.id = o.user_id
    GROUP BY u.id
    HAVING COUNT(o.id) > 0; -- または SUM(CASE WHEN ...) > 0
    ```

- 理論から見た使い分け

  - EXISTS = 「探す（見つかればOK）」という 動的・論理的 なアプローチ
  - GROUP BY = 「並べる（全部見てから決める）」という 静的・構造的 なアプローチ

比較表

|構文|数学的な問い|コンピュータへの負荷|
|--|--|--|
|EXISTS|「条件を満たすものが 1つでも存在するか？」|軽い（見つかったら探索終了）|
|GROUP BY|「各グループの 要素の構成や統計量はどうなっているか？」|重い（全件を分類・計算する必要がある）|

- Window関数を含めた場合

- 用途
  - 「存在するかどうか」だけでなく、「存在を確認しつつ、その行自体の詳細も保持し、さらに全体の順位や累計も出したい」 という場合

- 具体例

```sql
SELECT *
FROM (
    SELECT *,
           COUNT(*) OVER(PARTITION BY user_id) as order_count
    FROM Orders
) t
WHERE order_count > 0;
```

比較表

|項目|EXISTS(NOT EXISTS)|GROUP BY(HAVING, CASE式)|Window関数 (OVER)|
|--|--|--|--|
|理論|述語論理|集合論|集合論の拡張（OLAP）|
|視点|1行ずつの真偽判定|グループごとの要約|行を維持したままの並行計算|
|結果の行数|元のテーブルと同じ（か減少）|グループの数まで減少|元のテーブルと全く同じ|
|得意なこと|高速な存在判定|統計・集約レポート|順位付け、移動平均、前後行比較|
|特徴|条件を満たすものが存在するか、NOTの場合:条件を満たさないものが存在しない|条件を満たす個数が全体の個数と一致する|今の上から見て次の行はどう？|
